Binary Exploitation Challenge

Prompt
```
Exploiting bugs in programs can definitely be difficult. Not only do you need a certain amount of reverse engineering required to identify vulnerabilities, but you also need to weaponize that vulnerability somehow. To get new hackers started, we included our annotated source code along with the compiled program.
If you don't know where to start, download the source code and open it in a program with syntax highlighting such as notepad++ or gedit. If you don't have the ability to use either of those, you can always use vim.

You can connect to the problem at telnet challenge.acictf.com 19919 or nc challenge.acictf.com 19919
```

We're given a piece of source code and an executable. The executable (written in c) asks us for two integers and then multiplies them together and tells you what the least significant digit of the product is, however, it does this by using an unsafe integer value in an array. If you look at the source code if uses `flag[product % 10]` - In c, it's possible for flag[-1] to return a different memory address that it gets overflowed into. So the question is how do we get product % 10 to equal -1?

When using modulo operator if one of the values is a negative, the value is also gonna be negative, so we need to get product to be negative. In C the max int value is 2147483647. If you go over that value it flips the signed bit at the end and wraps back around to -1 from the sign bit and decrement for every value over. By this logic then 2147483658 (10 more than 1 over the max value) should return us a value of -10. -9 % 10 = -1, but there's an issue, the program checks to make sure you don't put in a value over the max int, so we need to factor this large number. 

Quick lookup on factordb.com and we see that  we get the following
2147483658 = 2 * 3 * 149 * 2402107
149 * 6 = 894

So we plug 894 and 2402107 into the program but there's an issue, we don't get the response we are expecting, we get this instead 
`2402107 * 894 = -2147483638 which ends in a '(null)'`

The thing that sticks out to me is that this result ends in an 8, not a 9 like we want it to, I wonder what would happen if we try to increment one of those values to tick that product slightly higher, so let's increment 894 to 895 and see what happens
```
âžœ  Downloads nc challenge.acictf.com 19919
Give me a number:
2402107
Give me another number:
895
2402107 * 895 = -2145081531 which ends in a 'ACI{ef5089532f47c2e43aac2847563}'
```

And there's the flag.

*Disclaimer - My math might be off slightly cause i'm not that great in c-memory management and bit overflows but the logic and idea is right as to how they want you to solve the problem
